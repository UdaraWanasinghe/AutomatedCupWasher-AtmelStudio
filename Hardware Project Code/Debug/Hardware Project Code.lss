
Hardware Project Code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a32  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000214  00800060  00000a32  00000ac6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000a  00800274  00800274  00000cda  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cda  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000d0c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000288  00000000  00000000  00000d48  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000026c9  00000000  00000000  00000fd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000def  00000000  00000000  00003699  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014d3  00000000  00000000  00004488  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000004d8  00000000  00000000  0000595c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000007bb  00000000  00000000  00005e34  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000f26  00000000  00000000  000065ef  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000248  00000000  00000000  00007515  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 85 01 	jmp	0x30a	; 0x30a <__vector_13>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	12 e0       	ldi	r17, 0x02	; 2
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e3       	ldi	r30, 0x32	; 50
  68:	fa e0       	ldi	r31, 0x0A	; 10
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	a4 37       	cpi	r26, 0x74	; 116
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	22 e0       	ldi	r18, 0x02	; 2
  78:	a4 e7       	ldi	r26, 0x74	; 116
  7a:	b2 e0       	ldi	r27, 0x02	; 2
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	ae 37       	cpi	r26, 0x7E	; 126
  82:	b2 07       	cpc	r27, r18
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 15 03 	call	0x62a	; 0x62a <main>
  8a:	0c 94 17 05 	jmp	0xa2e	; 0xa2e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <bluetooth_init>:
#include "bluetooth.h"
#include <avr/io.h>

// function to initialize UART communication
void bluetooth_init (){
	UBRRH |= (12 >> 8);										// set UBBR value for 9600 baud rate
  92:	80 b5       	in	r24, 0x20	; 32
  94:	80 bd       	out	0x20, r24	; 32
	UBRRL |= 12;
  96:	89 b1       	in	r24, 0x09	; 9
  98:	8c 60       	ori	r24, 0x0C	; 12
  9a:	89 b9       	out	0x09, r24	; 9
	UCSRB |= (1 << TXEN) | (1 << RXEN);						// enable receiver and transmitter
  9c:	8a b1       	in	r24, 0x0a	; 10
  9e:	88 61       	ori	r24, 0x18	; 24
  a0:	8a b9       	out	0x0a, r24	; 10
	UCSRC &= ~(1 << UMSEL);									// enable asynchronous mode
  a2:	80 b5       	in	r24, 0x20	; 32
  a4:	8f 7b       	andi	r24, 0xBF	; 191
  a6:	80 bd       	out	0x20, r24	; 32
	UCSRC|= (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1);		// 8bit data format
  a8:	80 b5       	in	r24, 0x20	; 32
  aa:	86 68       	ori	r24, 0x86	; 134
  ac:	80 bd       	out	0x20, r24	; 32
	UCSRA = 1 << U2X;										// double speed mode
  ae:	82 e0       	ldi	r24, 0x02	; 2
  b0:	8b b9       	out	0x0b, r24	; 11
	UCSRB |= (1 << RXCIE);									// enable receive complete interrupt
  b2:	57 9a       	sbi	0x0a, 7	; 10
  b4:	08 95       	ret

000000b6 <bluetooth_transmitc>:
}

// function to transmit character
void bluetooth_transmitc (char c)
{
	while (!( UCSRA & (1<<UDRE)));                // wait while register is free
  b6:	5d 9b       	sbis	0x0b, 5	; 11
  b8:	fe cf       	rjmp	.-4      	; 0xb6 <bluetooth_transmitc>
	UDR = c;                                   // load data in the register
  ba:	8c b9       	out	0x0c, r24	; 12
  bc:	08 95       	ret

000000be <bluetooth_transmits>:
}

// function to transmit string
void bluetooth_transmits (char *str)
{
  be:	cf 93       	push	r28
  c0:	df 93       	push	r29
  c2:	ec 01       	movw	r28, r24
	int i;
	for (i = 0; ;i++)
	{
		if (str[i] == '\0') break;
  c4:	88 81       	ld	r24, Y
  c6:	88 23       	and	r24, r24
  c8:	31 f0       	breq	.+12     	; 0xd6 <bluetooth_transmits+0x18>
  ca:	21 96       	adiw	r28, 0x01	; 1
		bluetooth_transmitc(str[i]);	// load data in the register
  cc:	0e 94 5b 00 	call	0xb6	; 0xb6 <bluetooth_transmitc>
void bluetooth_transmits (char *str)
{
	int i;
	for (i = 0; ;i++)
	{
		if (str[i] == '\0') break;
  d0:	89 91       	ld	r24, Y+
  d2:	81 11       	cpse	r24, r1
  d4:	fb cf       	rjmp	.-10     	; 0xcc <bluetooth_transmits+0xe>
		bluetooth_transmitc(str[i]);	// load data in the register
	}
}
  d6:	df 91       	pop	r29
  d8:	cf 91       	pop	r28
  da:	08 95       	ret

000000dc <keypad_init>:
	{'0', '0', '0', '0'}
};

//initialize keypad
void keypad_init(){
	KEYPAD_PORT = 0x0F; //columns 0, rows 1
  dc:	8f e0       	ldi	r24, 0x0F	; 15
  de:	88 bb       	out	0x18, r24	; 24
  e0:	08 95       	ret

000000e2 <scan_for_key>:
}

//scan for key once
char scan_for_key(){
	for (c = 0; c < 4; c++)
  e2:	10 92 7d 02 	sts	0x027D, r1	; 0x80027d <c+0x1>
  e6:	10 92 7c 02 	sts	0x027C, r1	; 0x80027c <c>
  ea:	80 e0       	ldi	r24, 0x00	; 0
  ec:	90 e0       	ldi	r25, 0x00	; 0
	{
		//one column output and 0 state, other columns input and tristate, shift by c times
		//rows output and pull up resistors activated, so at 1 state
		KEYPAD_DDR = 0x10 << c;
  ee:	40 e1       	ldi	r20, 0x10	; 16
  f0:	50 e0       	ldi	r21, 0x00	; 0
  f2:	9a 01       	movw	r18, r20
  f4:	02 c0       	rjmp	.+4      	; 0xfa <scan_for_key+0x18>
  f6:	22 0f       	add	r18, r18
  f8:	33 1f       	adc	r19, r19
  fa:	8a 95       	dec	r24
  fc:	e2 f7       	brpl	.-8      	; 0xf6 <scan_for_key+0x14>
  fe:	27 bb       	out	0x17, r18	; 23
		
		for (r = 0; r < 4; r++)
 100:	10 92 7b 02 	sts	0x027B, r1	; 0x80027b <r+0x1>
 104:	10 92 7a 02 	sts	0x027A, r1	; 0x80027a <r>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 108:	00 00       	nop
		{
			_delay_ms(.000001); //delay is essential to work properly
			if (!(KEYPAD_PIN & (0x01 << r))) //check column output is in row input
 10a:	26 b3       	in	r18, 0x16	; 22
 10c:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <r>
 110:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <r+0x1>
 114:	30 e0       	ldi	r19, 0x00	; 0
 116:	08 2e       	mov	r0, r24
 118:	02 c0       	rjmp	.+4      	; 0x11e <scan_for_key+0x3c>
 11a:	35 95       	asr	r19
 11c:	27 95       	ror	r18
 11e:	0a 94       	dec	r0
 120:	e2 f7       	brpl	.-8      	; 0x11a <scan_for_key+0x38>
 122:	20 fd       	sbrc	r18, 0
 124:	0f c0       	rjmp	.+30     	; 0x144 <scan_for_key+0x62>
			{
				return key_map[r][c];
 126:	88 0f       	add	r24, r24
 128:	99 1f       	adc	r25, r25
 12a:	88 0f       	add	r24, r24
 12c:	99 1f       	adc	r25, r25
 12e:	80 5a       	subi	r24, 0xA0	; 160
 130:	9f 4f       	sbci	r25, 0xFF	; 255
 132:	20 91 7c 02 	lds	r18, 0x027C	; 0x80027c <c>
 136:	30 91 7d 02 	lds	r19, 0x027D	; 0x80027d <c+0x1>
 13a:	fc 01       	movw	r30, r24
 13c:	e2 0f       	add	r30, r18
 13e:	f3 1f       	adc	r31, r19
 140:	80 81       	ld	r24, Z
 142:	08 95       	ret
	{
		//one column output and 0 state, other columns input and tristate, shift by c times
		//rows output and pull up resistors activated, so at 1 state
		KEYPAD_DDR = 0x10 << c;
		
		for (r = 0; r < 4; r++)
 144:	01 96       	adiw	r24, 0x01	; 1
 146:	90 93 7b 02 	sts	0x027B, r25	; 0x80027b <r+0x1>
 14a:	80 93 7a 02 	sts	0x027A, r24	; 0x80027a <r>
 14e:	04 97       	sbiw	r24, 0x04	; 4
 150:	dc f2       	brlt	.-74     	; 0x108 <scan_for_key+0x26>
	KEYPAD_PORT = 0x0F; //columns 0, rows 1
}

//scan for key once
char scan_for_key(){
	for (c = 0; c < 4; c++)
 152:	80 91 7c 02 	lds	r24, 0x027C	; 0x80027c <c>
 156:	90 91 7d 02 	lds	r25, 0x027D	; 0x80027d <c+0x1>
 15a:	01 96       	adiw	r24, 0x01	; 1
 15c:	90 93 7d 02 	sts	0x027D, r25	; 0x80027d <c+0x1>
 160:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <c>
 164:	84 30       	cpi	r24, 0x04	; 4
 166:	91 05       	cpc	r25, r1
 168:	24 f2       	brlt	.-120    	; 0xf2 <scan_for_key+0x10>
			{
				return key_map[r][c];
			}
		}
	}
	return 0xFF;
 16a:	8f ef       	ldi	r24, 0xFF	; 255
 16c:	08 95       	ret

0000016e <toggle_e>:

    while ( (c = pgm_read_byte(progmem_s++)) ) {
        lcd_putc(c);
    }

}/* lcd_puts_p */
 16e:	93 9a       	sbi	0x12, 3	; 18
 170:	00 c0       	rjmp	.+0      	; 0x172 <toggle_e+0x4>
 172:	93 98       	cbi	0x12, 3	; 18
 174:	08 95       	ret

00000176 <lcd_write>:
 176:	cf 93       	push	r28
 178:	c8 2f       	mov	r28, r24
 17a:	66 23       	and	r22, r22
 17c:	11 f0       	breq	.+4      	; 0x182 <lcd_write+0xc>
 17e:	a8 9a       	sbi	0x15, 0	; 21
 180:	01 c0       	rjmp	.+2      	; 0x184 <lcd_write+0xe>
 182:	a8 98       	cbi	0x15, 0	; 21
 184:	92 98       	cbi	0x12, 2	; 18
 186:	8c 9a       	sbi	0x11, 4	; 17
 188:	8d 9a       	sbi	0x11, 5	; 17
 18a:	8e 9a       	sbi	0x11, 6	; 17
 18c:	8f 9a       	sbi	0x11, 7	; 17
 18e:	97 98       	cbi	0x12, 7	; 18
 190:	96 98       	cbi	0x12, 6	; 18
 192:	95 98       	cbi	0x12, 5	; 18
 194:	94 98       	cbi	0x12, 4	; 18
 196:	cc 23       	and	r28, r28
 198:	0c f4       	brge	.+2      	; 0x19c <lcd_write+0x26>
 19a:	97 9a       	sbi	0x12, 7	; 18
 19c:	c6 fd       	sbrc	r28, 6
 19e:	96 9a       	sbi	0x12, 6	; 18
 1a0:	c5 fd       	sbrc	r28, 5
 1a2:	95 9a       	sbi	0x12, 5	; 18
 1a4:	c4 fd       	sbrc	r28, 4
 1a6:	94 9a       	sbi	0x12, 4	; 18
 1a8:	0e 94 b7 00 	call	0x16e	; 0x16e <toggle_e>
 1ac:	97 98       	cbi	0x12, 7	; 18
 1ae:	96 98       	cbi	0x12, 6	; 18
 1b0:	95 98       	cbi	0x12, 5	; 18
 1b2:	94 98       	cbi	0x12, 4	; 18
 1b4:	c3 fd       	sbrc	r28, 3
 1b6:	97 9a       	sbi	0x12, 7	; 18
 1b8:	c2 fd       	sbrc	r28, 2
 1ba:	96 9a       	sbi	0x12, 6	; 18
 1bc:	c1 fd       	sbrc	r28, 1
 1be:	95 9a       	sbi	0x12, 5	; 18
 1c0:	c0 fd       	sbrc	r28, 0
 1c2:	94 9a       	sbi	0x12, 4	; 18
 1c4:	0e 94 b7 00 	call	0x16e	; 0x16e <toggle_e>
 1c8:	94 9a       	sbi	0x12, 4	; 18
 1ca:	95 9a       	sbi	0x12, 5	; 18
 1cc:	96 9a       	sbi	0x12, 6	; 18
 1ce:	97 9a       	sbi	0x12, 7	; 18
 1d0:	cf 91       	pop	r28
 1d2:	08 95       	ret

000001d4 <lcd_read>:
 1d4:	88 23       	and	r24, r24
 1d6:	11 f0       	breq	.+4      	; 0x1dc <lcd_read+0x8>
 1d8:	a8 9a       	sbi	0x15, 0	; 21
 1da:	01 c0       	rjmp	.+2      	; 0x1de <lcd_read+0xa>
 1dc:	a8 98       	cbi	0x15, 0	; 21
 1de:	92 9a       	sbi	0x12, 2	; 18
 1e0:	8c 98       	cbi	0x11, 4	; 17
 1e2:	8d 98       	cbi	0x11, 5	; 17
 1e4:	8e 98       	cbi	0x11, 6	; 17
 1e6:	8f 98       	cbi	0x11, 7	; 17
 1e8:	93 9a       	sbi	0x12, 3	; 18
 1ea:	00 c0       	rjmp	.+0      	; 0x1ec <lcd_read+0x18>
 1ec:	84 9b       	sbis	0x10, 4	; 16
 1ee:	02 c0       	rjmp	.+4      	; 0x1f4 <lcd_read+0x20>
 1f0:	80 e1       	ldi	r24, 0x10	; 16
 1f2:	01 c0       	rjmp	.+2      	; 0x1f6 <lcd_read+0x22>
 1f4:	80 e0       	ldi	r24, 0x00	; 0
 1f6:	85 99       	sbic	0x10, 5	; 16
 1f8:	80 62       	ori	r24, 0x20	; 32
 1fa:	86 99       	sbic	0x10, 6	; 16
 1fc:	80 64       	ori	r24, 0x40	; 64
 1fe:	87 99       	sbic	0x10, 7	; 16
 200:	80 68       	ori	r24, 0x80	; 128
 202:	93 98       	cbi	0x12, 3	; 18
 204:	00 c0       	rjmp	.+0      	; 0x206 <lcd_read+0x32>
 206:	93 9a       	sbi	0x12, 3	; 18
 208:	00 c0       	rjmp	.+0      	; 0x20a <lcd_read+0x36>
 20a:	84 99       	sbic	0x10, 4	; 16
 20c:	81 60       	ori	r24, 0x01	; 1
 20e:	85 99       	sbic	0x10, 5	; 16
 210:	82 60       	ori	r24, 0x02	; 2
 212:	86 99       	sbic	0x10, 6	; 16
 214:	84 60       	ori	r24, 0x04	; 4
 216:	87 99       	sbic	0x10, 7	; 16
 218:	88 60       	ori	r24, 0x08	; 8
 21a:	93 98       	cbi	0x12, 3	; 18
 21c:	08 95       	ret

0000021e <lcd_waitbusy>:
 21e:	80 e0       	ldi	r24, 0x00	; 0
 220:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_read>
 224:	88 23       	and	r24, r24
 226:	dc f3       	brlt	.-10     	; 0x21e <lcd_waitbusy>
 228:	00 c0       	rjmp	.+0      	; 0x22a <lcd_waitbusy+0xc>
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	0e 94 ea 00 	call	0x1d4	; 0x1d4 <lcd_read>
 230:	08 95       	ret

00000232 <lcd_command>:
 232:	cf 93       	push	r28
 234:	c8 2f       	mov	r28, r24
 236:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_waitbusy>
 23a:	60 e0       	ldi	r22, 0x00	; 0
 23c:	8c 2f       	mov	r24, r28
 23e:	0e 94 bb 00 	call	0x176	; 0x176 <lcd_write>
 242:	cf 91       	pop	r28
 244:	08 95       	ret

00000246 <lcd_clrscr>:
 246:	81 e0       	ldi	r24, 0x01	; 1
 248:	0e 94 19 01 	call	0x232	; 0x232 <lcd_command>
 24c:	08 95       	ret

0000024e <lcd_putc>:
 24e:	cf 93       	push	r28
 250:	c8 2f       	mov	r28, r24
 252:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_waitbusy>
 256:	ca 30       	cpi	r28, 0x0A	; 10
 258:	49 f4       	brne	.+18     	; 0x26c <lcd_putc+0x1e>
 25a:	80 34       	cpi	r24, 0x40	; 64
 25c:	10 f0       	brcs	.+4      	; 0x262 <lcd_putc+0x14>
 25e:	80 e0       	ldi	r24, 0x00	; 0
 260:	01 c0       	rjmp	.+2      	; 0x264 <lcd_putc+0x16>
 262:	80 e4       	ldi	r24, 0x40	; 64
 264:	80 58       	subi	r24, 0x80	; 128
 266:	0e 94 19 01 	call	0x232	; 0x232 <lcd_command>
 26a:	13 c0       	rjmp	.+38     	; 0x292 <lcd_putc+0x44>
 26c:	80 31       	cpi	r24, 0x10	; 16
 26e:	29 f4       	brne	.+10     	; 0x27a <lcd_putc+0x2c>
 270:	60 e0       	ldi	r22, 0x00	; 0
 272:	80 ec       	ldi	r24, 0xC0	; 192
 274:	0e 94 bb 00 	call	0x176	; 0x176 <lcd_write>
 278:	06 c0       	rjmp	.+12     	; 0x286 <lcd_putc+0x38>
 27a:	80 35       	cpi	r24, 0x50	; 80
 27c:	21 f4       	brne	.+8      	; 0x286 <lcd_putc+0x38>
 27e:	60 e0       	ldi	r22, 0x00	; 0
 280:	80 e8       	ldi	r24, 0x80	; 128
 282:	0e 94 bb 00 	call	0x176	; 0x176 <lcd_write>
 286:	0e 94 0f 01 	call	0x21e	; 0x21e <lcd_waitbusy>
 28a:	61 e0       	ldi	r22, 0x01	; 1
 28c:	8c 2f       	mov	r24, r28
 28e:	0e 94 bb 00 	call	0x176	; 0x176 <lcd_write>
 292:	cf 91       	pop	r28
 294:	08 95       	ret

00000296 <lcd_init>:
                   LCD_DISP_ON_CURSOR      display on, cursor on
                   LCD_DISP_CURSOR_BLINK   display on, cursor on flashing
Returns:  none
*************************************************************************/
void lcd_init(uint8_t dispAttr)
{
 296:	1f 93       	push	r17
 298:	cf 93       	push	r28
 29a:	df 93       	push	r29
 29c:	18 2f       	mov	r17, r24
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
    }
    else
    {
        /* configure all port bits as output (LCD data and control lines on different ports */
        DDR(LCD_RS_PORT)    |= _BV(LCD_RS_PIN);
 29e:	a0 9a       	sbi	0x14, 0	; 20
        DDR(LCD_RW_PORT)    |= _BV(LCD_RW_PIN);
 2a0:	8a 9a       	sbi	0x11, 2	; 17
        DDR(LCD_E_PORT)     |= _BV(LCD_E_PIN);
 2a2:	8b 9a       	sbi	0x11, 3	; 17
        DDR(LCD_DATA0_PORT) |= _BV(LCD_DATA0_PIN);
 2a4:	8c 9a       	sbi	0x11, 4	; 17
        DDR(LCD_DATA1_PORT) |= _BV(LCD_DATA1_PIN);
 2a6:	8d 9a       	sbi	0x11, 5	; 17
        DDR(LCD_DATA2_PORT) |= _BV(LCD_DATA2_PIN);
 2a8:	8e 9a       	sbi	0x11, 6	; 17
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
 2aa:	8f 9a       	sbi	0x11, 7	; 17
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 2ac:	80 ea       	ldi	r24, 0xA0	; 160
 2ae:	9f e0       	ldi	r25, 0x0F	; 15
 2b0:	01 97       	sbiw	r24, 0x01	; 1
 2b2:	f1 f7       	brne	.-4      	; 0x2b0 <lcd_init+0x1a>
        DDR(LCD_DATA3_PORT) |= _BV(LCD_DATA3_PIN);
    }
    delay(16000);        /* wait 16ms or more after power-on       */
    
    /* initial write to lcd is 8bit */
    LCD_DATA1_PORT |= _BV(LCD_DATA1_PIN);  // _BV(LCD_FUNCTION)>>4;
 2b4:	95 9a       	sbi	0x12, 5	; 18
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
 2b6:	94 9a       	sbi	0x12, 4	; 18
    lcd_e_toggle();
 2b8:	0e 94 b7 00 	call	0x16e	; 0x16e <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 2bc:	80 ee       	ldi	r24, 0xE0	; 224
 2be:	94 e0       	ldi	r25, 0x04	; 4
 2c0:	01 97       	sbiw	r24, 0x01	; 1
 2c2:	f1 f7       	brne	.-4      	; 0x2c0 <lcd_init+0x2a>
    LCD_DATA0_PORT |= _BV(LCD_DATA0_PIN);  // _BV(LCD_FUNCTION_8BIT)>>4;
    lcd_e_toggle();
    delay(4992);         /* delay, busy flag can't be checked here */
   
    /* repeat last command */ 
    lcd_e_toggle();      
 2c4:	0e 94 b7 00 	call	0x16e	; 0x16e <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 2c8:	c0 e1       	ldi	r28, 0x10	; 16
 2ca:	d0 e0       	ldi	r29, 0x00	; 0
 2cc:	ce 01       	movw	r24, r28
 2ce:	01 97       	sbiw	r24, 0x01	; 1
 2d0:	f1 f7       	brne	.-4      	; 0x2ce <lcd_init+0x38>
    /* repeat last command */ 
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */
    
    /* repeat last command a third time */
    lcd_e_toggle();      
 2d2:	0e 94 b7 00 	call	0x16e	; 0x16e <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 2d6:	ce 01       	movw	r24, r28
 2d8:	01 97       	sbiw	r24, 0x01	; 1
 2da:	f1 f7       	brne	.-4      	; 0x2d8 <lcd_init+0x42>
    /* repeat last command a third time */
    lcd_e_toggle();      
    delay(64);           /* delay, busy flag can't be checked here */

    /* now configure for 4bit mode */
    LCD_DATA0_PORT &= ~_BV(LCD_DATA0_PIN);   // LCD_FUNCTION_4BIT_1LINE>>4
 2dc:	94 98       	cbi	0x12, 4	; 18
    lcd_e_toggle();
 2de:	0e 94 b7 00 	call	0x16e	; 0x16e <toggle_e>
static inline void _delayFourCycles(unsigned int __count)
{
    if ( __count == 0 )    
        __asm__ __volatile__( "rjmp 1f\n 1:" );    // 2 cycles
    else
        __asm__ __volatile__ (
 2e2:	21 97       	sbiw	r28, 0x01	; 1
 2e4:	f1 f7       	brne	.-4      	; 0x2e2 <lcd_init+0x4c>
    /* Display with KS0073 controller requires special commands for enabling 4 line mode */
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_ON);
	lcd_command(KS0073_4LINES_MODE);
	lcd_command(KS0073_EXTENDED_FUNCTION_REGISTER_OFF);
#else
    lcd_command(LCD_FUNCTION_DEFAULT);      /* function set: display lines  */
 2e6:	88 e2       	ldi	r24, 0x28	; 40
 2e8:	0e 94 19 01 	call	0x232	; 0x232 <lcd_command>
#endif
    lcd_command(LCD_DISP_OFF);              /* display off                  */
 2ec:	88 e0       	ldi	r24, 0x08	; 8
 2ee:	0e 94 19 01 	call	0x232	; 0x232 <lcd_command>
    lcd_clrscr();                           /* display clear                */ 
 2f2:	0e 94 23 01 	call	0x246	; 0x246 <lcd_clrscr>
    lcd_command(LCD_MODE_DEFAULT);          /* set entry mode               */
 2f6:	86 e0       	ldi	r24, 0x06	; 6
 2f8:	0e 94 19 01 	call	0x232	; 0x232 <lcd_command>
    lcd_command(dispAttr);                  /* display/cursor control       */
 2fc:	81 2f       	mov	r24, r17
 2fe:	0e 94 19 01 	call	0x232	; 0x232 <lcd_command>

}/* lcd_init */
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	1f 91       	pop	r17
 308:	08 95       	ret

0000030a <__vector_13>:
}

void show_message(char* message){
	lcd_clrscr();
	lcd_puts(message);
}
 30a:	1f 92       	push	r1
 30c:	0f 92       	push	r0
 30e:	0f b6       	in	r0, 0x3f	; 63
 310:	0f 92       	push	r0
 312:	11 24       	eor	r1, r1
 314:	8f 93       	push	r24
 316:	8c b1       	in	r24, 0x0c	; 12
 318:	81 34       	cpi	r24, 0x41	; 65
 31a:	21 f4       	brne	.+8      	; 0x324 <__vector_13+0x1a>
 31c:	81 e0       	ldi	r24, 0x01	; 1
 31e:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <SLEEP_FLAG>
 322:	21 c0       	rjmp	.+66     	; 0x366 <__vector_13+0x5c>
 324:	82 34       	cpi	r24, 0x42	; 66
 326:	41 f4       	brne	.+16     	; 0x338 <__vector_13+0x2e>
 328:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <SLEEP_FLAG>
 32c:	88 23       	and	r24, r24
 32e:	d9 f0       	breq	.+54     	; 0x366 <__vector_13+0x5c>
 330:	81 e0       	ldi	r24, 0x01	; 1
 332:	80 93 78 02 	sts	0x0278, r24	; 0x800278 <WAKE_FLAG>
 336:	17 c0       	rjmp	.+46     	; 0x366 <__vector_13+0x5c>
 338:	83 34       	cpi	r24, 0x43	; 67
 33a:	21 f4       	brne	.+8      	; 0x344 <__vector_13+0x3a>
 33c:	81 e0       	ldi	r24, 0x01	; 1
 33e:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <SKIP_FLAG>
 342:	11 c0       	rjmp	.+34     	; 0x366 <__vector_13+0x5c>
 344:	84 34       	cpi	r24, 0x44	; 68
 346:	21 f4       	brne	.+8      	; 0x350 <__vector_13+0x46>
 348:	81 e0       	ldi	r24, 0x01	; 1
 34a:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <WAIT_FLAG>
 34e:	0b c0       	rjmp	.+22     	; 0x366 <__vector_13+0x5c>
 350:	85 34       	cpi	r24, 0x45	; 69
 352:	21 f4       	brne	.+8      	; 0x35c <__vector_13+0x52>
 354:	81 e0       	ldi	r24, 0x01	; 1
 356:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <REFILL_FLAG>
 35a:	05 c0       	rjmp	.+10     	; 0x366 <__vector_13+0x5c>
 35c:	86 34       	cpi	r24, 0x46	; 70
 35e:	19 f4       	brne	.+6      	; 0x366 <__vector_13+0x5c>
 360:	81 e0       	ldi	r24, 0x01	; 1
 362:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <__data_end>
 366:	8f 91       	pop	r24
 368:	0f 90       	pop	r0
 36a:	0f be       	out	0x3f, r0	; 63
 36c:	0f 90       	pop	r0
 36e:	1f 90       	pop	r1
 370:	18 95       	reti

00000372 <update_liquid_level>:
 372:	cf 93       	push	r28
 374:	df 93       	push	r29
 376:	00 d0       	rcall	.+0      	; 0x378 <update_liquid_level+0x6>
 378:	00 d0       	rcall	.+0      	; 0x37a <update_liquid_level+0x8>
 37a:	cd b7       	in	r28, 0x3d	; 61
 37c:	de b7       	in	r29, 0x3e	; 62
 37e:	4a e0       	ldi	r20, 0x0A	; 10
 380:	50 e0       	ldi	r21, 0x00	; 0
 382:	be 01       	movw	r22, r28
 384:	6f 5f       	subi	r22, 0xFF	; 255
 386:	7f 4f       	sbci	r23, 0xFF	; 255
 388:	0e 94 d7 04 	call	0x9ae	; 0x9ae <itoa>
 38c:	be 01       	movw	r22, r28
 38e:	6f 5f       	subi	r22, 0xFF	; 255
 390:	7f 4f       	sbci	r23, 0xFF	; 255
 392:	80 e7       	ldi	r24, 0x70	; 112
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	0e 94 cc 04 	call	0x998	; 0x998 <strcat>
 39a:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
 39e:	0f 90       	pop	r0
 3a0:	0f 90       	pop	r0
 3a2:	0f 90       	pop	r0
 3a4:	0f 90       	pop	r0
 3a6:	df 91       	pop	r29
 3a8:	cf 91       	pop	r28
 3aa:	08 95       	ret

000003ac <scan_keypad>:
 3ac:	0e 94 71 00 	call	0xe2	; 0xe2 <scan_for_key>
 3b0:	81 34       	cpi	r24, 0x41	; 65
 3b2:	21 f4       	brne	.+8      	; 0x3bc <scan_keypad+0x10>
 3b4:	81 e0       	ldi	r24, 0x01	; 1
 3b6:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <SLEEP_FLAG>
 3ba:	08 95       	ret
 3bc:	82 34       	cpi	r24, 0x42	; 66
 3be:	39 f4       	brne	.+14     	; 0x3ce <scan_keypad+0x22>
 3c0:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <SLEEP_FLAG>
 3c4:	81 30       	cpi	r24, 0x01	; 1
 3c6:	c9 f4       	brne	.+50     	; 0x3fa <scan_keypad+0x4e>
 3c8:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <WAKE_FLAG>
 3cc:	08 95       	ret
 3ce:	83 34       	cpi	r24, 0x43	; 67
 3d0:	19 f4       	brne	.+6      	; 0x3d8 <scan_keypad+0x2c>
 3d2:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <SKIP_FLAG>
 3d6:	08 95       	ret
 3d8:	84 34       	cpi	r24, 0x44	; 68
 3da:	21 f4       	brne	.+8      	; 0x3e4 <scan_keypad+0x38>
 3dc:	81 e0       	ldi	r24, 0x01	; 1
 3de:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <WAIT_FLAG>
 3e2:	08 95       	ret
 3e4:	85 34       	cpi	r24, 0x45	; 69
 3e6:	21 f4       	brne	.+8      	; 0x3f0 <scan_keypad+0x44>
 3e8:	81 e0       	ldi	r24, 0x01	; 1
 3ea:	80 93 75 02 	sts	0x0275, r24	; 0x800275 <REFILL_FLAG>
 3ee:	08 95       	ret
 3f0:	86 34       	cpi	r24, 0x46	; 70
 3f2:	19 f4       	brne	.+6      	; 0x3fa <scan_keypad+0x4e>
 3f4:	81 e0       	ldi	r24, 0x01	; 1
 3f6:	80 93 74 02 	sts	0x0274, r24	; 0x800274 <__data_end>
 3fa:	08 95       	ret

000003fc <mc_init>:
 3fc:	84 b7       	in	r24, 0x34	; 52
 3fe:	80 68       	ori	r24, 0x80	; 128
 400:	84 bf       	out	0x34, r24	; 52
 402:	84 b7       	in	r24, 0x34	; 52
 404:	80 68       	ori	r24, 0x80	; 128
 406:	84 bf       	out	0x34, r24	; 52
 408:	2f e7       	ldi	r18, 0x7F	; 127
 40a:	8a e1       	ldi	r24, 0x1A	; 26
 40c:	96 e0       	ldi	r25, 0x06	; 6
 40e:	21 50       	subi	r18, 0x01	; 1
 410:	80 40       	sbci	r24, 0x00	; 0
 412:	90 40       	sbci	r25, 0x00	; 0
 414:	e1 f7       	brne	.-8      	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
 416:	00 c0       	rjmp	.+0      	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
 418:	00 00       	nop
 41a:	78 94       	sei
 41c:	0e 94 8e 04 	call	0x91c	; 0x91c <sensors_init>
 420:	0e 94 b1 04 	call	0x962	; 0x962 <solenoid_init>
 424:	0e 94 67 04 	call	0x8ce	; 0x8ce <motor_init>
 428:	0e 94 6e 00 	call	0xdc	; 0xdc <keypad_init>
 42c:	0e 94 49 00 	call	0x92	; 0x92 <bluetooth_init>
 430:	8c e0       	ldi	r24, 0x0C	; 12
 432:	0e 94 4b 01 	call	0x296	; 0x296 <lcd_init>
 436:	08 95       	ret

00000438 <is_cup_at>:
 438:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
 43c:	21 e0       	ldi	r18, 0x01	; 1
 43e:	30 e0       	ldi	r19, 0x00	; 0
 440:	89 2b       	or	r24, r25
 442:	11 f0       	breq	.+4      	; 0x448 <is_cup_at+0x10>
 444:	20 e0       	ldi	r18, 0x00	; 0
 446:	30 e0       	ldi	r19, 0x00	; 0
 448:	c9 01       	movw	r24, r18
 44a:	08 95       	ret

0000044c <show_animated_message>:

void show_animated_message(char* message){
 44c:	cf 93       	push	r28
 44e:	df 93       	push	r29
 450:	ec 01       	movw	r28, r24
	lcd_clrscr();
 452:	0e 94 23 01 	call	0x246	; 0x246 <lcd_clrscr>
	for (int i = 0; message[i] != '\0'; i++)
 456:	88 81       	ld	r24, Y
 458:	88 23       	and	r24, r24
 45a:	61 f0       	breq	.+24     	; 0x474 <show_animated_message+0x28>
 45c:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_putc(message[i]);
 45e:	0e 94 27 01 	call	0x24e	; 0x24e <lcd_putc>
 462:	8f e0       	ldi	r24, 0x0F	; 15
 464:	97 e2       	ldi	r25, 0x27	; 39
 466:	01 97       	sbiw	r24, 0x01	; 1
 468:	f1 f7       	brne	.-4      	; 0x466 <show_animated_message+0x1a>
 46a:	00 c0       	rjmp	.+0      	; 0x46c <show_animated_message+0x20>
 46c:	00 00       	nop
	lcd_puts(message);
}

void show_animated_message(char* message){
	lcd_clrscr();
	for (int i = 0; message[i] != '\0'; i++)
 46e:	89 91       	ld	r24, Y+
 470:	81 11       	cpse	r24, r1
 472:	f5 cf       	rjmp	.-22     	; 0x45e <show_animated_message+0x12>
	{
		lcd_putc(message[i]);
		_delay_ms(40);
	}
}
 474:	df 91       	pop	r29
 476:	cf 91       	pop	r28
 478:	08 95       	ret

0000047a <initialize>:
	}
}

//initialize machine
void initialize(){
	if (!read_sensor(LASER_SENSOR1) && !read_sensor(LASER_SENSOR2))
 47a:	81 e0       	ldi	r24, 0x01	; 1
 47c:	90 e0       	ldi	r25, 0x00	; 0
 47e:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
 482:	89 2b       	or	r24, r25
 484:	e1 f4       	brne	.+56     	; 0x4be <initialize+0x44>
 486:	82 e0       	ldi	r24, 0x02	; 2
 488:	90 e0       	ldi	r25, 0x00	; 0
 48a:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
 48e:	89 2b       	or	r24, r25
 490:	b1 f4       	brne	.+44     	; 0x4be <initialize+0x44>
	{
		show_animated_message("Initializing...\nPlease wait :)");
 492:	84 e7       	ldi	r24, 0x74	; 116
 494:	90 e0       	ldi	r25, 0x00	; 0
 496:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		start_main_motor(MOTOR_CLOCKWISE);
 49a:	81 e0       	ldi	r24, 0x01	; 1
 49c:	90 e0       	ldi	r25, 0x00	; 0
 49e:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <start_main_motor>
		while(!read_sensor(LASER_SENSOR1) && !read_sensor(LASER_SENSOR2));
 4a2:	81 e0       	ldi	r24, 0x01	; 1
 4a4:	90 e0       	ldi	r25, 0x00	; 0
 4a6:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
 4aa:	89 2b       	or	r24, r25
 4ac:	31 f4       	brne	.+12     	; 0x4ba <initialize+0x40>
 4ae:	82 e0       	ldi	r24, 0x02	; 2
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
 4b6:	89 2b       	or	r24, r25
 4b8:	a1 f3       	breq	.-24     	; 0x4a2 <initialize+0x28>
		stop_main_motor();
 4ba:	0e 94 76 04 	call	0x8ec	; 0x8ec <stop_main_motor>
 4be:	08 95       	ret

000004c0 <execute_sleep_command>:
	DRAIN_FLAG = drain_flag;
}

//getters
uint8_t get_sleep_flag(){
	return SLEEP_FLAG;
 4c0:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <SLEEP_FLAG>
	}
}

//execute sleep command if available
bool execute_sleep_command(){
	if (get_sleep_flag())
 4c4:	88 23       	and	r24, r24
 4c6:	59 f1       	breq	.+86     	; 0x51e <execute_sleep_command+0x5e>
	{
		bluetooth_transmits("RR:A");
 4c8:	83 e9       	ldi	r24, 0x93	; 147
 4ca:	90 e0       	ldi	r25, 0x00	; 0
 4cc:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
		show_animated_message("I'm sleeping ^_^\nDon't disturb");
 4d0:	88 e9       	ldi	r24, 0x98	; 152
 4d2:	90 e0       	ldi	r25, 0x00	; 0
 4d4:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		
		while(get_sleep_flag()){
 4d8:	0e c0       	rjmp	.+28     	; 0x4f6 <execute_sleep_command+0x36>
			scan_keypad();
 4da:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
uint8_t get_sleep_flag(){
	return SLEEP_FLAG;
}

uint8_t get_wake_flag(){
	return WAKE_FLAG;
 4de:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <WAKE_FLAG>
		bluetooth_transmits("RR:A");
		show_animated_message("I'm sleeping ^_^\nDon't disturb");
		
		while(get_sleep_flag()){
			scan_keypad();
			if (get_wake_flag())
 4e2:	88 23       	and	r24, r24
 4e4:	41 f0       	breq	.+16     	; 0x4f6 <execute_sleep_command+0x36>
static volatile uint8_t REFILL_FLAG;
static volatile uint8_t DRAIN_FLAG;

//setters
void set_sleep_flag(uint8_t sleep_flag){
	SLEEP_FLAG = sleep_flag;
 4e6:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <SLEEP_FLAG>
}

void set_wake_flag(uint8_t wake_flag){
	WAKE_FLAG = wake_flag;
 4ea:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <WAKE_FLAG>
			scan_keypad();
			if (get_wake_flag())
			{
				set_sleep_flag(FALSE);
				set_wake_flag(FALSE);
				bluetooth_transmits("RR:B");
 4ee:	87 eb       	ldi	r24, 0xB7	; 183
 4f0:	90 e0       	ldi	r25, 0x00	; 0
 4f2:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
	DRAIN_FLAG = drain_flag;
}

//getters
uint8_t get_sleep_flag(){
	return SLEEP_FLAG;
 4f6:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <SLEEP_FLAG>
	if (get_sleep_flag())
	{
		bluetooth_transmits("RR:A");
		show_animated_message("I'm sleeping ^_^\nDon't disturb");
		
		while(get_sleep_flag()){
 4fa:	81 11       	cpse	r24, r1
 4fc:	ee cf       	rjmp	.-36     	; 0x4da <execute_sleep_command+0x1a>
				set_wake_flag(FALSE);
				bluetooth_transmits("RR:B");
			}
		}
		
		show_animated_message("I'm awake :D");
 4fe:	8c eb       	ldi	r24, 0xBC	; 188
 500:	90 e0       	ldi	r25, 0x00	; 0
 502:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 506:	2f ed       	ldi	r18, 0xDF	; 223
 508:	83 e9       	ldi	r24, 0x93	; 147
 50a:	94 e0       	ldi	r25, 0x04	; 4
 50c:	21 50       	subi	r18, 0x01	; 1
 50e:	80 40       	sbci	r24, 0x00	; 0
 510:	90 40       	sbci	r25, 0x00	; 0
 512:	e1 f7       	brne	.-8      	; 0x50c <execute_sleep_command+0x4c>
 514:	00 c0       	rjmp	.+0      	; 0x516 <execute_sleep_command+0x56>
 516:	00 00       	nop
		_delay_ms(MESSAGE_DELAY);
		return TRUE;
 518:	81 e0       	ldi	r24, 0x01	; 1
 51a:	90 e0       	ldi	r25, 0x00	; 0
 51c:	08 95       	ret
	}
	return FALSE;
 51e:	80 e0       	ldi	r24, 0x00	; 0
 520:	90 e0       	ldi	r25, 0x00	; 0
}
 522:	08 95       	ret

00000524 <execute_wait_command>:
uint8_t get_skip_flag(){
	return SKIP_FLAG;
}

uint8_t get_wait_flag(){
	return WAIT_FLAG;
 524:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <WAIT_FLAG>
	return FALSE;
}

//execute wait command if available
void execute_wait_command(){
	while (get_wait_flag())
 528:	88 23       	and	r24, r24
 52a:	c9 f0       	breq	.+50     	; 0x55e <execute_wait_command+0x3a>
void set_skip_flag(uint8_t skip_flag){
	SKIP_FLAG = skip_flag;
}

void set_wait_flag(uint8_t wait_flag){
	WAIT_FLAG = wait_flag;
 52c:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <WAIT_FLAG>
//execute wait command if available
void execute_wait_command(){
	while (get_wait_flag())
	{
		set_wait_flag(FALSE);
		bluetooth_transmits("RR:D");
 530:	89 ec       	ldi	r24, 0xC9	; 201
 532:	90 e0       	ldi	r25, 0x00	; 0
 534:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
		show_animated_message("Waiting... :)");
 538:	8e ec       	ldi	r24, 0xCE	; 206
 53a:	90 e0       	ldi	r25, 0x00	; 0
 53c:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 540:	2f e7       	ldi	r18, 0x7F	; 127
 542:	8a e1       	ldi	r24, 0x1A	; 26
 544:	96 e0       	ldi	r25, 0x06	; 6
 546:	21 50       	subi	r18, 0x01	; 1
 548:	80 40       	sbci	r24, 0x00	; 0
 54a:	90 40       	sbci	r25, 0x00	; 0
 54c:	e1 f7       	brne	.-8      	; 0x546 <execute_wait_command+0x22>
 54e:	00 c0       	rjmp	.+0      	; 0x550 <execute_wait_command+0x2c>
 550:	00 00       	nop
		_delay_ms(USER_WAIT_DELAY);
		scan_keypad();
 552:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
uint8_t get_skip_flag(){
	return SKIP_FLAG;
}

uint8_t get_wait_flag(){
	return WAIT_FLAG;
 556:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <WAIT_FLAG>
	return FALSE;
}

//execute wait command if available
void execute_wait_command(){
	while (get_wait_flag())
 55a:	81 11       	cpse	r24, r1
 55c:	e7 cf       	rjmp	.-50     	; 0x52c <execute_wait_command+0x8>
 55e:	08 95       	ret

00000560 <execute_refill_command>:
uint8_t get_wait_flag(){
	return WAIT_FLAG;
}

uint8_t get_refill_flag(){
	return REFILL_FLAG;
 560:	80 91 75 02 	lds	r24, 0x0275	; 0x800275 <REFILL_FLAG>
	}
}

//execute refill command if available
void execute_refill_command(){
	if (get_refill_flag())
 564:	88 23       	and	r24, r24
 566:	71 f1       	breq	.+92     	; 0x5c4 <execute_refill_command+0x64>
void set_wait_flag(uint8_t wait_flag){
	WAIT_FLAG = wait_flag;
}

void set_refill_flag(uint8_t refill_flag){
	REFILL_FLAG = refill_flag;
 568:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <REFILL_FLAG>
//execute refill command if available
void execute_refill_command(){
	if (get_refill_flag())
	{
		set_refill_flag(FALSE);
		bluetooth_transmits("RR:E");
 56c:	8c ed       	ldi	r24, 0xDC	; 220
 56e:	90 e0       	ldi	r25, 0x00	; 0
 570:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
		show_animated_message("Refilling... :)");
 574:	81 ee       	ldi	r24, 0xE1	; 225
 576:	90 e0       	ldi	r25, 0x00	; 0
 578:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		if (read_ll_sensor() < LIQUID_MAX)
 57c:	0e 94 ad 04 	call	0x95a	; 0x95a <read_ll_sensor>
 580:	88 3e       	cpi	r24, 0xE8	; 232
 582:	93 40       	sbci	r25, 0x03	; 3
 584:	24 f4       	brge	.+8      	; 0x58e <execute_refill_command+0x2e>
		{
			start_syringe_motor(MOTOR_CLOCKWISE);
 586:	81 e0       	ldi	r24, 0x01	; 1
 588:	90 e0       	ldi	r25, 0x00	; 0
 58a:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <start_syringe_motor>
		}
		while (1)
		{
			int read = read_ll_sensor();
 58e:	0e 94 ad 04 	call	0x95a	; 0x95a <read_ll_sensor>
			if(read > LIQUID_MAX){
 592:	89 3e       	cpi	r24, 0xE9	; 233
 594:	23 e0       	ldi	r18, 0x03	; 3
 596:	92 07       	cpc	r25, r18
 598:	84 f0       	brlt	.+32     	; 0x5ba <execute_refill_command+0x5a>
				stop_syringe_motor();
 59a:	0e 94 85 04 	call	0x90a	; 0x90a <stop_syringe_motor>
				show_animated_message("Refilling\ndone... :)");
 59e:	81 ef       	ldi	r24, 0xF1	; 241
 5a0:	90 e0       	ldi	r25, 0x00	; 0
 5a2:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 5a6:	8f ed       	ldi	r24, 0xDF	; 223
 5a8:	93 e9       	ldi	r25, 0x93	; 147
 5aa:	24 e0       	ldi	r18, 0x04	; 4
 5ac:	81 50       	subi	r24, 0x01	; 1
 5ae:	90 40       	sbci	r25, 0x00	; 0
 5b0:	20 40       	sbci	r18, 0x00	; 0
 5b2:	e1 f7       	brne	.-8      	; 0x5ac <execute_refill_command+0x4c>
 5b4:	00 c0       	rjmp	.+0      	; 0x5b6 <execute_refill_command+0x56>
 5b6:	00 00       	nop
 5b8:	08 95       	ret
				_delay_ms(MESSAGE_DELAY);
				break;
			}
			update_liquid_level(read);
 5ba:	0e 94 b9 01 	call	0x372	; 0x372 <update_liquid_level>
			scan_keypad();
 5be:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
		}
 5c2:	e5 cf       	rjmp	.-54     	; 0x58e <execute_refill_command+0x2e>
 5c4:	08 95       	ret

000005c6 <execute_drain_command>:
uint8_t get_refill_flag(){
	return REFILL_FLAG;
}

uint8_t get_drain_flag(){
	return DRAIN_FLAG;
 5c6:	80 91 74 02 	lds	r24, 0x0274	; 0x800274 <__data_end>
	}
}

//execute drain command if available
void execute_drain_command(){
	if (get_drain_flag())
 5ca:	88 23       	and	r24, r24
 5cc:	69 f1       	breq	.+90     	; 0x628 <execute_drain_command+0x62>
void set_refill_flag(uint8_t refill_flag){
	REFILL_FLAG = refill_flag;
}

void set_drain_flag(uint8_t drain_flag){
	DRAIN_FLAG = drain_flag;
 5ce:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <__data_end>
//execute drain command if available
void execute_drain_command(){
	if (get_drain_flag())
	{
		set_drain_flag(FALSE);
		bluetooth_transmits("RR:F");
 5d2:	86 e0       	ldi	r24, 0x06	; 6
 5d4:	91 e0       	ldi	r25, 0x01	; 1
 5d6:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
		show_animated_message("Draining... :)");
 5da:	8b e0       	ldi	r24, 0x0B	; 11
 5dc:	91 e0       	ldi	r25, 0x01	; 1
 5de:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		if (read_ll_sensor() > LIQUID_MIN)
 5e2:	0e 94 ad 04 	call	0x95a	; 0x95a <read_ll_sensor>
 5e6:	85 36       	cpi	r24, 0x65	; 101
 5e8:	91 05       	cpc	r25, r1
 5ea:	24 f0       	brlt	.+8      	; 0x5f4 <execute_drain_command+0x2e>
		{
			start_syringe_motor(MOTOR_ANTICLOCKWISE);
 5ec:	80 e0       	ldi	r24, 0x00	; 0
 5ee:	90 e0       	ldi	r25, 0x00	; 0
 5f0:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <start_syringe_motor>
		}
		while (1)
		{
			int read = read_ll_sensor();
 5f4:	0e 94 ad 04 	call	0x95a	; 0x95a <read_ll_sensor>
			if(read < LIQUID_MIN){
 5f8:	84 36       	cpi	r24, 0x64	; 100
 5fa:	91 05       	cpc	r25, r1
 5fc:	84 f4       	brge	.+32     	; 0x61e <execute_drain_command+0x58>
				stop_syringe_motor();
 5fe:	0e 94 85 04 	call	0x90a	; 0x90a <stop_syringe_motor>
				show_animated_message("Draining\ndone... :)");
 602:	8a e1       	ldi	r24, 0x1A	; 26
 604:	91 e0       	ldi	r25, 0x01	; 1
 606:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 60a:	2f ed       	ldi	r18, 0xDF	; 223
 60c:	83 e9       	ldi	r24, 0x93	; 147
 60e:	94 e0       	ldi	r25, 0x04	; 4
 610:	21 50       	subi	r18, 0x01	; 1
 612:	80 40       	sbci	r24, 0x00	; 0
 614:	90 40       	sbci	r25, 0x00	; 0
 616:	e1 f7       	brne	.-8      	; 0x610 <execute_drain_command+0x4a>
 618:	00 c0       	rjmp	.+0      	; 0x61a <execute_drain_command+0x54>
 61a:	00 00       	nop
 61c:	08 95       	ret
				_delay_ms(MESSAGE_DELAY);
				break;
			}
			update_liquid_level(read);
 61e:	0e 94 b9 01 	call	0x372	; 0x372 <update_liquid_level>
			scan_keypad();
 622:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
		}
 626:	e6 cf       	rjmp	.-52     	; 0x5f4 <execute_drain_command+0x2e>
 628:	08 95       	ret

0000062a <main>:
}

int main(void)
{
	//initialize global variables
	SLEEP_FLAG = 0;
 62a:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <SLEEP_FLAG>
	WAKE_FLAG = 0;
 62e:	10 92 78 02 	sts	0x0278, r1	; 0x800278 <WAKE_FLAG>
	SKIP_FLAG = 0;
 632:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <SKIP_FLAG>
	WAIT_FLAG = 0;
 636:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <WAIT_FLAG>
	REFILL_FLAG = 0;
 63a:	10 92 75 02 	sts	0x0275, r1	; 0x800275 <REFILL_FLAG>
	DRAIN_FLAG = 0;
 63e:	10 92 74 02 	sts	0x0274, r1	; 0x800274 <__data_end>
	
	//initialize micro controller
	mc_init();
 642:	0e 94 fe 01 	call	0x3fc	; 0x3fc <mc_init>
	
	show_animated_message(" Welcome ^.^");//message
 646:	8e e2       	ldi	r24, 0x2E	; 46
 648:	91 e0       	ldi	r25, 0x01	; 1
 64a:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 64e:	2f ed       	ldi	r18, 0xDF	; 223
 650:	83 e9       	ldi	r24, 0x93	; 147
 652:	94 e0       	ldi	r25, 0x04	; 4
 654:	21 50       	subi	r18, 0x01	; 1
 656:	80 40       	sbci	r24, 0x00	; 0
 658:	90 40       	sbci	r25, 0x00	; 0
 65a:	e1 f7       	brne	.-8      	; 0x654 <main+0x2a>
 65c:	00 c0       	rjmp	.+0      	; 0x65e <main+0x34>
 65e:	00 00       	nop
	_delay_ms(MESSAGE_DELAY);
	show_animated_message("   Automated\n   Cup Washer");//message
 660:	8b e3       	ldi	r24, 0x3B	; 59
 662:	91 e0       	ldi	r25, 0x01	; 1
 664:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 668:	2f ed       	ldi	r18, 0xDF	; 223
 66a:	83 e9       	ldi	r24, 0x93	; 147
 66c:	94 e0       	ldi	r25, 0x04	; 4
 66e:	21 50       	subi	r18, 0x01	; 1
 670:	80 40       	sbci	r24, 0x00	; 0
 672:	90 40       	sbci	r25, 0x00	; 0
 674:	e1 f7       	brne	.-8      	; 0x66e <main+0x44>
 676:	00 c0       	rjmp	.+0      	; 0x678 <main+0x4e>
 678:	00 00       	nop
	_delay_ms(MESSAGE_DELAY);
	
	//initialize machine
	initialize();
 67a:	0e 94 3d 02 	call	0x47a	; 0x47a <initialize>
	
	while(1){
		/********** Procedure **********/
		
		/***** execute sleep command if available *****/
		execute_sleep_command();
 67e:	0e 94 60 02 	call	0x4c0	; 0x4c0 <execute_sleep_command>
		
		/***** execute refill command if available *****/
		execute_refill_command();
 682:	0e 94 b0 02 	call	0x560	; 0x560 <execute_refill_command>
		
		/***** execute drain command if available *****/
		execute_drain_command();
 686:	0e 94 e3 02 	call	0x5c6	; 0x5c6 <execute_drain_command>
		
		/***** update liquid level *****/
		update_liquid_level(read_ll_sensor());
 68a:	0e 94 ad 04 	call	0x95a	; 0x95a <read_ll_sensor>
 68e:	0e 94 b9 01 	call	0x372	; 0x372 <update_liquid_level>
		
		/***** check for cup at begin *****/
		if (!is_cup_at(LASER_SENSOR1))
 692:	81 e0       	ldi	r24, 0x01	; 1
 694:	90 e0       	ldi	r25, 0x00	; 0
 696:	0e 94 1c 02 	call	0x438	; 0x438 <is_cup_at>
 69a:	89 2b       	or	r24, r25
 69c:	a9 f4       	brne	.+42     	; 0x6c8 <main+0x9e>
		{
			show_animated_message("Please insert\na cup :)");//message
 69e:	86 e5       	ldi	r24, 0x56	; 86
 6a0:	91 e0       	ldi	r25, 0x01	; 1
 6a2:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 6a6:	10 c0       	rjmp	.+32     	; 0x6c8 <main+0x9e>
		}
		while(!is_cup_at(LASER_SENSOR1)){
			scan_keypad();
 6a8:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
			if (execute_sleep_command())
 6ac:	0e 94 60 02 	call	0x4c0	; 0x4c0 <execute_sleep_command>
 6b0:	89 2b       	or	r24, r25
 6b2:	51 f0       	breq	.+20     	; 0x6c8 <main+0x9e>
			{
				if (!is_cup_at(LASER_SENSOR1))
 6b4:	81 e0       	ldi	r24, 0x01	; 1
 6b6:	90 e0       	ldi	r25, 0x00	; 0
 6b8:	0e 94 1c 02 	call	0x438	; 0x438 <is_cup_at>
 6bc:	89 2b       	or	r24, r25
 6be:	21 f4       	brne	.+8      	; 0x6c8 <main+0x9e>
				{
					show_animated_message("Please insert\na cup :)");//message
 6c0:	86 e5       	ldi	r24, 0x56	; 86
 6c2:	91 e0       	ldi	r25, 0x01	; 1
 6c4:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		/***** check for cup at begin *****/
		if (!is_cup_at(LASER_SENSOR1))
		{
			show_animated_message("Please insert\na cup :)");//message
		}
		while(!is_cup_at(LASER_SENSOR1)){
 6c8:	81 e0       	ldi	r24, 0x01	; 1
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	0e 94 1c 02 	call	0x438	; 0x438 <is_cup_at>
 6d0:	89 2b       	or	r24, r25
 6d2:	51 f3       	breq	.-44     	; 0x6a8 <main+0x7e>
 6d4:	2f e7       	ldi	r18, 0x7F	; 127
 6d6:	8a e1       	ldi	r24, 0x1A	; 26
 6d8:	96 e0       	ldi	r25, 0x06	; 6
 6da:	21 50       	subi	r18, 0x01	; 1
 6dc:	80 40       	sbci	r24, 0x00	; 0
 6de:	90 40       	sbci	r25, 0x00	; 0
 6e0:	e1 f7       	brne	.-8      	; 0x6da <main+0xb0>
 6e2:	00 c0       	rjmp	.+0      	; 0x6e4 <main+0xba>
 6e4:	00 00       	nop
			}
		}
		_delay_ms(USER_WAIT_DELAY);
		
		/***** execute wait command if available *****/
		execute_wait_command();
 6e6:	0e 94 92 02 	call	0x524	; 0x524 <execute_wait_command>
		
		/***** rotate motor to next *****/
		show_animated_message("Process started!\n:)");//message
 6ea:	8d e6       	ldi	r24, 0x6D	; 109
 6ec:	91 e0       	ldi	r25, 0x01	; 1
 6ee:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		start_main_motor(MOTOR_CLOCKWISE);
 6f2:	81 e0       	ldi	r24, 0x01	; 1
 6f4:	90 e0       	ldi	r25, 0x00	; 0
 6f6:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <start_main_motor>
		while(1){
			scan_keypad();
 6fa:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
	return !read_sensor(sensor);
}

bool is_at_place(int sensor){
	//light on sensor -> high voltage
	return read_sensor(sensor);
 6fe:	81 e0       	ldi	r24, 0x01	; 1
 700:	90 e0       	ldi	r25, 0x00	; 0
 702:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
		/***** rotate motor to next *****/
		show_animated_message("Process started!\n:)");//message
		start_main_motor(MOTOR_CLOCKWISE);
		while(1){
			scan_keypad();
			if(is_at_place(LASER_SENSOR1)) break;
 706:	89 2b       	or	r24, r25
 708:	c1 f3       	breq	.-16     	; 0x6fa <main+0xd0>
		}
		stop_main_motor();
 70a:	0e 94 76 04 	call	0x8ec	; 0x8ec <stop_main_motor>
uint8_t get_wake_flag(){
	return WAKE_FLAG;
}

uint8_t get_skip_flag(){
	return SKIP_FLAG;
 70e:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <SKIP_FLAG>
			if(is_at_place(LASER_SENSOR1)) break;
		}
		stop_main_motor();
		
		/***** skip process if skip command available *****/
		if (!get_skip_flag())
 712:	81 11       	cpse	r24, r1
 714:	29 c0       	rjmp	.+82     	; 0x768 <main+0x13e>
		{
			/***** start cleaning process one *****/
			show_animated_message("Cleaning process\none in progress!");//message
 716:	81 e8       	ldi	r24, 0x81	; 129
 718:	91 e0       	ldi	r25, 0x01	; 1
 71a:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
			open_valve(SOLENOID_VALVE1);
 71e:	83 e0       	ldi	r24, 0x03	; 3
 720:	90 e0       	ldi	r25, 0x00	; 0
 722:	0e 94 b5 04 	call	0x96a	; 0x96a <open_valve>
			start_syringe_motor(MOTOR_CLOCKWISE);
 726:	81 e0       	ldi	r24, 0x01	; 1
 728:	90 e0       	ldi	r25, 0x00	; 0
 72a:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <start_syringe_motor>
 72e:	2f e7       	ldi	r18, 0x7F	; 127
 730:	89 ea       	ldi	r24, 0xA9	; 169
 732:	93 e0       	ldi	r25, 0x03	; 3
 734:	21 50       	subi	r18, 0x01	; 1
 736:	80 40       	sbci	r24, 0x00	; 0
 738:	90 40       	sbci	r25, 0x00	; 0
 73a:	e1 f7       	brne	.-8      	; 0x734 <main+0x10a>
 73c:	00 c0       	rjmp	.+0      	; 0x73e <main+0x114>
 73e:	00 00       	nop
			_delay_ms(HOLE_FADE_AWAY_DELAY);
			stop_syringe_motor();
 740:	0e 94 85 04 	call	0x90a	; 0x90a <stop_syringe_motor>
 744:	2f ef       	ldi	r18, 0xFF	; 255
 746:	84 e3       	ldi	r24, 0x34	; 52
 748:	9c e0       	ldi	r25, 0x0C	; 12
 74a:	21 50       	subi	r18, 0x01	; 1
 74c:	80 40       	sbci	r24, 0x00	; 0
 74e:	90 40       	sbci	r25, 0x00	; 0
 750:	e1 f7       	brne	.-8      	; 0x74a <main+0x120>
 752:	00 c0       	rjmp	.+0      	; 0x754 <main+0x12a>
 754:	00 00       	nop
			_delay_ms(CLEANING_DELAY);
			close_valve(SOLENOID_VALVE1);
 756:	83 e0       	ldi	r24, 0x03	; 3
 758:	90 e0       	ldi	r25, 0x00	; 0
 75a:	0e 94 c0 04 	call	0x980	; 0x980 <close_valve>
			show_animated_message("Process one\completed! :)");//message
 75e:	83 ea       	ldi	r24, 0xA3	; 163
 760:	91 e0       	ldi	r25, 0x01	; 1
 762:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 766:	13 c0       	rjmp	.+38     	; 0x78e <main+0x164>
			
		}else{
			bluetooth_transmits("RR:C");
 768:	8c eb       	ldi	r24, 0xBC	; 188
 76a:	91 e0       	ldi	r25, 0x01	; 1
 76c:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
			show_animated_message("Skipped cleaning\nprocess one :O");
 770:	81 ec       	ldi	r24, 0xC1	; 193
 772:	91 e0       	ldi	r25, 0x01	; 1
 774:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
void set_wake_flag(uint8_t wake_flag){
	WAKE_FLAG = wake_flag;
}

void set_skip_flag(uint8_t skip_flag){
	SKIP_FLAG = skip_flag;
 778:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <SKIP_FLAG>
 77c:	2f ed       	ldi	r18, 0xDF	; 223
 77e:	83 e9       	ldi	r24, 0x93	; 147
 780:	94 e0       	ldi	r25, 0x04	; 4
 782:	21 50       	subi	r18, 0x01	; 1
 784:	80 40       	sbci	r24, 0x00	; 0
 786:	90 40       	sbci	r25, 0x00	; 0
 788:	e1 f7       	brne	.-8      	; 0x782 <main+0x158>
 78a:	00 c0       	rjmp	.+0      	; 0x78c <main+0x162>
 78c:	00 00       	nop
			_delay_ms(MESSAGE_DELAY);
			
		}
		
		/***** rotate motor to next *****/
		start_main_motor(MOTOR_CLOCKWISE);
 78e:	81 e0       	ldi	r24, 0x01	; 1
 790:	90 e0       	ldi	r25, 0x00	; 0
 792:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <start_main_motor>
 796:	2f e7       	ldi	r18, 0x7F	; 127
 798:	89 ea       	ldi	r24, 0xA9	; 169
 79a:	93 e0       	ldi	r25, 0x03	; 3
 79c:	21 50       	subi	r18, 0x01	; 1
 79e:	80 40       	sbci	r24, 0x00	; 0
 7a0:	90 40       	sbci	r25, 0x00	; 0
 7a2:	e1 f7       	brne	.-8      	; 0x79c <main+0x172>
 7a4:	00 c0       	rjmp	.+0      	; 0x7a6 <main+0x17c>
 7a6:	00 00       	nop
		_delay_ms(HOLE_FADE_AWAY_DELAY); //wait while hole is faded away
		while(1){
			scan_keypad();
 7a8:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
	return !read_sensor(sensor);
}

bool is_at_place(int sensor){
	//light on sensor -> high voltage
	return read_sensor(sensor);
 7ac:	81 e0       	ldi	r24, 0x01	; 1
 7ae:	90 e0       	ldi	r25, 0x00	; 0
 7b0:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
		/***** rotate motor to next *****/
		start_main_motor(MOTOR_CLOCKWISE);
		_delay_ms(HOLE_FADE_AWAY_DELAY); //wait while hole is faded away
		while(1){
			scan_keypad();
			if(is_at_place(LASER_SENSOR1)) break;
 7b4:	89 2b       	or	r24, r25
 7b6:	c1 f3       	breq	.-16     	; 0x7a8 <main+0x17e>
		}
		stop_main_motor();
 7b8:	0e 94 76 04 	call	0x8ec	; 0x8ec <stop_main_motor>
uint8_t get_wake_flag(){
	return WAKE_FLAG;
}

uint8_t get_skip_flag(){
	return SKIP_FLAG;
 7bc:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <SKIP_FLAG>
			scan_keypad();
			if(is_at_place(LASER_SENSOR1)) break;
		}
		stop_main_motor();
		
		if (!get_skip_flag())
 7c0:	81 11       	cpse	r24, r1
 7c2:	1a c0       	rjmp	.+52     	; 0x7f8 <main+0x1ce>
		{
			/***** start cleaning process two *****/
			show_animated_message("Cleaning process\ntwo in progress!");//message
 7c4:	81 ee       	ldi	r24, 0xE1	; 225
 7c6:	91 e0       	ldi	r25, 0x01	; 1
 7c8:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
			open_valve(SOLENOID_VALVE2);
 7cc:	84 e0       	ldi	r24, 0x04	; 4
 7ce:	90 e0       	ldi	r25, 0x00	; 0
 7d0:	0e 94 b5 04 	call	0x96a	; 0x96a <open_valve>
 7d4:	2f ef       	ldi	r18, 0xFF	; 255
 7d6:	84 e3       	ldi	r24, 0x34	; 52
 7d8:	9c e0       	ldi	r25, 0x0C	; 12
 7da:	21 50       	subi	r18, 0x01	; 1
 7dc:	80 40       	sbci	r24, 0x00	; 0
 7de:	90 40       	sbci	r25, 0x00	; 0
 7e0:	e1 f7       	brne	.-8      	; 0x7da <main+0x1b0>
 7e2:	00 c0       	rjmp	.+0      	; 0x7e4 <main+0x1ba>
 7e4:	00 00       	nop
			_delay_ms(CLEANING_DELAY);
			close_valve(SOLENOID_VALVE2);
 7e6:	84 e0       	ldi	r24, 0x04	; 4
 7e8:	90 e0       	ldi	r25, 0x00	; 0
 7ea:	0e 94 c0 04 	call	0x980	; 0x980 <close_valve>
			show_animated_message("Process two\ncompleted! :)");//message
 7ee:	83 e0       	ldi	r24, 0x03	; 3
 7f0:	92 e0       	ldi	r25, 0x02	; 2
 7f2:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 7f6:	13 c0       	rjmp	.+38     	; 0x81e <main+0x1f4>
			
		}else{
			bluetooth_transmits("RR:C");
 7f8:	8c eb       	ldi	r24, 0xBC	; 188
 7fa:	91 e0       	ldi	r25, 0x01	; 1
 7fc:	0e 94 5f 00 	call	0xbe	; 0xbe <bluetooth_transmits>
			show_animated_message("Skipped cleaning\nprocess two :O");
 800:	8d e1       	ldi	r24, 0x1D	; 29
 802:	92 e0       	ldi	r25, 0x02	; 2
 804:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
void set_wake_flag(uint8_t wake_flag){
	WAKE_FLAG = wake_flag;
}

void set_skip_flag(uint8_t skip_flag){
	SKIP_FLAG = skip_flag;
 808:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <SKIP_FLAG>
 80c:	2f ed       	ldi	r18, 0xDF	; 223
 80e:	83 e9       	ldi	r24, 0x93	; 147
 810:	94 e0       	ldi	r25, 0x04	; 4
 812:	21 50       	subi	r18, 0x01	; 1
 814:	80 40       	sbci	r24, 0x00	; 0
 816:	90 40       	sbci	r25, 0x00	; 0
 818:	e1 f7       	brne	.-8      	; 0x812 <main+0x1e8>
 81a:	00 c0       	rjmp	.+0      	; 0x81c <main+0x1f2>
 81c:	00 00       	nop
			set_skip_flag(FALSE);
			_delay_ms(MESSAGE_DELAY);
		}

		/***** rotate motor to next *****/
		start_main_motor(MOTOR_CLOCKWISE);
 81e:	81 e0       	ldi	r24, 0x01	; 1
 820:	90 e0       	ldi	r25, 0x00	; 0
 822:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <start_main_motor>
 826:	2f e7       	ldi	r18, 0x7F	; 127
 828:	89 ea       	ldi	r24, 0xA9	; 169
 82a:	93 e0       	ldi	r25, 0x03	; 3
 82c:	21 50       	subi	r18, 0x01	; 1
 82e:	80 40       	sbci	r24, 0x00	; 0
 830:	90 40       	sbci	r25, 0x00	; 0
 832:	e1 f7       	brne	.-8      	; 0x82c <main+0x202>
 834:	00 c0       	rjmp	.+0      	; 0x836 <main+0x20c>
 836:	00 00       	nop
		_delay_ms(HOLE_FADE_AWAY_DELAY); //wait while hole is faded away
		while(1){
			scan_keypad();
 838:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
	return !read_sensor(sensor);
}

bool is_at_place(int sensor){
	//light on sensor -> high voltage
	return read_sensor(sensor);
 83c:	81 e0       	ldi	r24, 0x01	; 1
 83e:	90 e0       	ldi	r25, 0x00	; 0
 840:	0e 94 9f 04 	call	0x93e	; 0x93e <read_sensor>
		/***** rotate motor to next *****/
		start_main_motor(MOTOR_CLOCKWISE);
		_delay_ms(HOLE_FADE_AWAY_DELAY); //wait while hole is faded away
		while(1){
			scan_keypad();
			if(is_at_place(LASER_SENSOR1)) break;
 844:	89 2b       	or	r24, r25
 846:	c1 f3       	breq	.-16     	; 0x838 <main+0x20e>
		}
		stop_main_motor();
 848:	0e 94 76 04 	call	0x8ec	; 0x8ec <stop_main_motor>
 84c:	2f ed       	ldi	r18, 0xDF	; 223
 84e:	83 e9       	ldi	r24, 0x93	; 147
 850:	94 e0       	ldi	r25, 0x04	; 4
 852:	21 50       	subi	r18, 0x01	; 1
 854:	80 40       	sbci	r24, 0x00	; 0
 856:	90 40       	sbci	r25, 0x00	; 0
 858:	e1 f7       	brne	.-8      	; 0x852 <main+0x228>
 85a:	00 c0       	rjmp	.+0      	; 0x85c <main+0x232>
 85c:	00 00       	nop
		
		_delay_ms(MESSAGE_DELAY);
		show_animated_message("Cleaning\ncompleted! :)");//message
 85e:	8d e3       	ldi	r24, 0x3D	; 61
 860:	92 e0       	ldi	r25, 0x02	; 2
 862:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 866:	2f ed       	ldi	r18, 0xDF	; 223
 868:	83 e9       	ldi	r24, 0x93	; 147
 86a:	94 e0       	ldi	r25, 0x04	; 4
 86c:	21 50       	subi	r18, 0x01	; 1
 86e:	80 40       	sbci	r24, 0x00	; 0
 870:	90 40       	sbci	r25, 0x00	; 0
 872:	e1 f7       	brne	.-8      	; 0x86c <__stack+0xd>
 874:	00 c0       	rjmp	.+0      	; 0x876 <__stack+0x17>
 876:	00 00       	nop
		_delay_ms(MESSAGE_DELAY);
		
		/***** wait while cup is removed *****/
		if (is_cup_at(LASER_SENSOR2))
 878:	82 e0       	ldi	r24, 0x02	; 2
 87a:	90 e0       	ldi	r25, 0x00	; 0
 87c:	0e 94 1c 02 	call	0x438	; 0x438 <is_cup_at>
 880:	89 2b       	or	r24, r25
 882:	a9 f0       	breq	.+42     	; 0x8ae <__stack+0x4f>
		{
			show_animated_message("Please remove\ncup from tray :)");//message
 884:	84 e5       	ldi	r24, 0x54	; 84
 886:	92 e0       	ldi	r25, 0x02	; 2
 888:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
 88c:	10 c0       	rjmp	.+32     	; 0x8ae <__stack+0x4f>
		}
		while(is_cup_at(LASER_SENSOR2)){
			scan_keypad();
 88e:	0e 94 d6 01 	call	0x3ac	; 0x3ac <scan_keypad>
			if (execute_sleep_command())
 892:	0e 94 60 02 	call	0x4c0	; 0x4c0 <execute_sleep_command>
 896:	89 2b       	or	r24, r25
 898:	51 f0       	breq	.+20     	; 0x8ae <__stack+0x4f>
			{
				if (is_cup_at(LASER_SENSOR2))
 89a:	82 e0       	ldi	r24, 0x02	; 2
 89c:	90 e0       	ldi	r25, 0x00	; 0
 89e:	0e 94 1c 02 	call	0x438	; 0x438 <is_cup_at>
 8a2:	89 2b       	or	r24, r25
 8a4:	21 f0       	breq	.+8      	; 0x8ae <__stack+0x4f>
				{
					show_animated_message("Please remove\ncup from tray :)");//message
 8a6:	84 e5       	ldi	r24, 0x54	; 84
 8a8:	92 e0       	ldi	r25, 0x02	; 2
 8aa:	0e 94 26 02 	call	0x44c	; 0x44c <show_animated_message>
		/***** wait while cup is removed *****/
		if (is_cup_at(LASER_SENSOR2))
		{
			show_animated_message("Please remove\ncup from tray :)");//message
		}
		while(is_cup_at(LASER_SENSOR2)){
 8ae:	82 e0       	ldi	r24, 0x02	; 2
 8b0:	90 e0       	ldi	r25, 0x00	; 0
 8b2:	0e 94 1c 02 	call	0x438	; 0x438 <is_cup_at>
 8b6:	89 2b       	or	r24, r25
 8b8:	51 f7       	brne	.-44     	; 0x88e <__stack+0x2f>
 8ba:	2f e7       	ldi	r18, 0x7F	; 127
 8bc:	8a e1       	ldi	r24, 0x1A	; 26
 8be:	96 e0       	ldi	r25, 0x06	; 6
 8c0:	21 50       	subi	r18, 0x01	; 1
 8c2:	80 40       	sbci	r24, 0x00	; 0
 8c4:	90 40       	sbci	r25, 0x00	; 0
 8c6:	e1 f7       	brne	.-8      	; 0x8c0 <__stack+0x61>
 8c8:	00 c0       	rjmp	.+0      	; 0x8ca <__stack+0x6b>
 8ca:	00 00       	nop
 8cc:	d8 ce       	rjmp	.-592    	; 0x67e <main+0x54>

000008ce <motor_init>:

#include "motor.h"

void motor_init(){
	//set motor pins as output
	MOTOR_DDR |= (1 << MAIN_MOTOR_PIN1) | (1 << MAIN_MOTOR_PIN2) | (1 << SYRINGE_MOTOR_PIN1) | (1 << SYRINGE_MOTOR_PIN2);
 8ce:	84 b3       	in	r24, 0x14	; 20
 8d0:	8e 61       	ori	r24, 0x1E	; 30
 8d2:	84 bb       	out	0x14, r24	; 20
 8d4:	08 95       	ret

000008d6 <start_main_motor>:
}

void start_main_motor(int direction){
	if (direction == MOTOR_CLOCKWISE)
 8d6:	81 30       	cpi	r24, 0x01	; 1
 8d8:	91 05       	cpc	r25, r1
 8da:	19 f4       	brne	.+6      	; 0x8e2 <start_main_motor+0xc>
	{
		MOTOR_PORT |= (1 << MAIN_MOTOR_PIN1);	// pin 1 high
 8dc:	a9 9a       	sbi	0x15, 1	; 21
		MOTOR_PORT &= ~(1 << MAIN_MOTOR_PIN2);	//pin 2 low
 8de:	aa 98       	cbi	0x15, 2	; 21
 8e0:	08 95       	ret

	}else if (direction == MOTOR_ANTICLOCKWISE)
 8e2:	89 2b       	or	r24, r25
 8e4:	11 f4       	brne	.+4      	; 0x8ea <start_main_motor+0x14>
	{
		MOTOR_PORT &= ~(1 << MAIN_MOTOR_PIN1);	// pin 1 low
 8e6:	a9 98       	cbi	0x15, 1	; 21
		MOTOR_PORT |= (1 << MAIN_MOTOR_PIN2);	//pin 2 high
 8e8:	aa 9a       	sbi	0x15, 2	; 21
 8ea:	08 95       	ret

000008ec <stop_main_motor>:
	}
}

void stop_main_motor(){
	MOTOR_PORT &= ~((1 << MAIN_MOTOR_PIN1) | (1 << MAIN_MOTOR_PIN2));	//set pin1 & pin2 low
 8ec:	85 b3       	in	r24, 0x15	; 21
 8ee:	89 7f       	andi	r24, 0xF9	; 249
 8f0:	85 bb       	out	0x15, r24	; 21
 8f2:	08 95       	ret

000008f4 <start_syringe_motor>:

}

void start_syringe_motor(int direction){
	if (direction == MOTOR_CLOCKWISE)
 8f4:	81 30       	cpi	r24, 0x01	; 1
 8f6:	91 05       	cpc	r25, r1
 8f8:	19 f4       	brne	.+6      	; 0x900 <start_syringe_motor+0xc>
	{
		MOTOR_PORT |= (1 << SYRINGE_MOTOR_PIN1);	// pin 1 high
 8fa:	ab 9a       	sbi	0x15, 3	; 21
		MOTOR_PORT &= ~(1 << SYRINGE_MOTOR_PIN2);	//pin 2 low
 8fc:	ac 98       	cbi	0x15, 4	; 21
 8fe:	08 95       	ret

	}else if (direction == MOTOR_ANTICLOCKWISE)
 900:	89 2b       	or	r24, r25
 902:	11 f4       	brne	.+4      	; 0x908 <start_syringe_motor+0x14>
	{
		MOTOR_PORT &= ~(1 << SYRINGE_MOTOR_PIN1);	// pin 1 low
 904:	ab 98       	cbi	0x15, 3	; 21
		MOTOR_PORT |= (1 << SYRINGE_MOTOR_PIN2);	//pin 2 high
 906:	ac 9a       	sbi	0x15, 4	; 21
 908:	08 95       	ret

0000090a <stop_syringe_motor>:
	}
}

void stop_syringe_motor(){
	MOTOR_PORT &= ~((1 << SYRINGE_MOTOR_PIN1) | (1 << SYRINGE_MOTOR_PIN2));	//set pin1 & pin2 low
 90a:	85 b3       	in	r24, 0x15	; 21
 90c:	87 7e       	andi	r24, 0xE7	; 231
 90e:	85 bb       	out	0x15, r24	; 21
 910:	08 95       	ret

00000912 <adc_init>:

//initialize ADC
void adc_init()
{
	// AREF = AVcc
	ADMUX = (1<<REFS0);
 912:	80 e4       	ldi	r24, 0x40	; 64
 914:	87 b9       	out	0x07, r24	; 7
	
	// ADC Enable and prescaler of 128
	// 16000000/128 = 125000
	ADCSRA = (1<<ADEN)|(1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0);
 916:	87 e8       	ldi	r24, 0x87	; 135
 918:	86 b9       	out	0x06, r24	; 6
 91a:	08 95       	ret

0000091c <sensors_init>:
#include "sensors.h"
#define bool int

void sensors_init(){
	//set laser sensor pins as input
	SENSOR_DDR &= ~((1 << LIQUID_LEVEL_SENSOR) | (1 << LASER_SENSOR1) | (1 << LASER_SENSOR2));
 91c:	8a b3       	in	r24, 0x1a	; 26
 91e:	88 7f       	andi	r24, 0xF8	; 248
 920:	8a bb       	out	0x1a, r24	; 26
	adc_init();
 922:	0e 94 89 04 	call	0x912	; 0x912 <adc_init>
 926:	08 95       	ret

00000928 <adc_read>:
{
	// select the corresponding channel 0~7
	// ANDing with 7? will always keep the value
	// of ch between 0 and 7
	ch &= 0b00000111;  // AND operation with 7
	ADMUX = (ADMUX & 0xF8)|ch; // clears the bottom 3 bits before ORing
 928:	97 b1       	in	r25, 0x07	; 7
 92a:	98 7f       	andi	r25, 0xF8	; 248
 92c:	87 70       	andi	r24, 0x07	; 7
 92e:	89 2b       	or	r24, r25
 930:	87 b9       	out	0x07, r24	; 7
	
	// start single convertion
	// write 1? to ADSC
	ADCSRA |= (1<<ADSC);
 932:	36 9a       	sbi	0x06, 6	; 6
	
	// wait for conversion to complete
	// ADSC becomes 0? again
	// till then, run loop continuously
	while(ADCSRA & (1<<ADSC));
 934:	36 99       	sbic	0x06, 6	; 6
 936:	fe cf       	rjmp	.-4      	; 0x934 <adc_read+0xc>
	
	return (ADC);
 938:	84 b1       	in	r24, 0x04	; 4
 93a:	95 b1       	in	r25, 0x05	; 5
}
 93c:	08 95       	ret

0000093e <read_sensor>:

bool read_sensor(int sensor_pin){
	//return pin value
	return SENSOR_PIN & (1 << sensor_pin);
 93e:	29 b3       	in	r18, 0x19	; 25
 940:	41 e0       	ldi	r20, 0x01	; 1
 942:	50 e0       	ldi	r21, 0x00	; 0
 944:	ba 01       	movw	r22, r20
 946:	02 c0       	rjmp	.+4      	; 0x94c <read_sensor+0xe>
 948:	66 0f       	add	r22, r22
 94a:	77 1f       	adc	r23, r23
 94c:	8a 95       	dec	r24
 94e:	e2 f7       	brpl	.-8      	; 0x948 <read_sensor+0xa>
 950:	cb 01       	movw	r24, r22
 952:	30 e0       	ldi	r19, 0x00	; 0
}
 954:	82 23       	and	r24, r18
 956:	93 23       	and	r25, r19
 958:	08 95       	ret

0000095a <read_ll_sensor>:

//read from liquid level sensor
int read_ll_sensor(){
	return adc_read(LIQUID_LEVEL_SENSOR); // read ADC from channel of liquid level sensor
 95a:	80 e0       	ldi	r24, 0x00	; 0
 95c:	0e 94 94 04 	call	0x928	; 0x928 <adc_read>
 960:	08 95       	ret

00000962 <solenoid_init>:
#include <avr/io.h>
#include "solenoid.h"

void solenoid_init(){
	//set solenoid pins as output
	SOLENOID_DDR |= (1 << SOLENOID_VALVE1) | (1 << SOLENOID_VALVE2);
 962:	8a b3       	in	r24, 0x1a	; 26
 964:	88 61       	ori	r24, 0x18	; 24
 966:	8a bb       	out	0x1a, r24	; 26
 968:	08 95       	ret

0000096a <open_valve>:
}

void open_valve(int valve_pin){
	//set valve pin 1
	SOLENOID_PORT |= (1 << valve_pin);
 96a:	9b b3       	in	r25, 0x1b	; 27
 96c:	21 e0       	ldi	r18, 0x01	; 1
 96e:	30 e0       	ldi	r19, 0x00	; 0
 970:	02 c0       	rjmp	.+4      	; 0x976 <open_valve+0xc>
 972:	22 0f       	add	r18, r18
 974:	33 1f       	adc	r19, r19
 976:	8a 95       	dec	r24
 978:	e2 f7       	brpl	.-8      	; 0x972 <open_valve+0x8>
 97a:	29 2b       	or	r18, r25
 97c:	2b bb       	out	0x1b, r18	; 27
 97e:	08 95       	ret

00000980 <close_valve>:
}

void close_valve(int valve_pin){
	//set valve pin 0
	SOLENOID_PORT &= ~(1 << valve_pin);
 980:	9b b3       	in	r25, 0x1b	; 27
 982:	21 e0       	ldi	r18, 0x01	; 1
 984:	30 e0       	ldi	r19, 0x00	; 0
 986:	02 c0       	rjmp	.+4      	; 0x98c <close_valve+0xc>
 988:	22 0f       	add	r18, r18
 98a:	33 1f       	adc	r19, r19
 98c:	8a 95       	dec	r24
 98e:	e2 f7       	brpl	.-8      	; 0x988 <close_valve+0x8>
 990:	20 95       	com	r18
 992:	29 23       	and	r18, r25
 994:	2b bb       	out	0x1b, r18	; 27
 996:	08 95       	ret

00000998 <strcat>:
 998:	fb 01       	movw	r30, r22
 99a:	dc 01       	movw	r26, r24
 99c:	0d 90       	ld	r0, X+
 99e:	00 20       	and	r0, r0
 9a0:	e9 f7       	brne	.-6      	; 0x99c <strcat+0x4>
 9a2:	11 97       	sbiw	r26, 0x01	; 1
 9a4:	01 90       	ld	r0, Z+
 9a6:	0d 92       	st	X+, r0
 9a8:	00 20       	and	r0, r0
 9aa:	e1 f7       	brne	.-8      	; 0x9a4 <strcat+0xc>
 9ac:	08 95       	ret

000009ae <itoa>:
 9ae:	45 32       	cpi	r20, 0x25	; 37
 9b0:	51 05       	cpc	r21, r1
 9b2:	20 f4       	brcc	.+8      	; 0x9bc <itoa+0xe>
 9b4:	42 30       	cpi	r20, 0x02	; 2
 9b6:	10 f0       	brcs	.+4      	; 0x9bc <itoa+0xe>
 9b8:	0c 94 e2 04 	jmp	0x9c4	; 0x9c4 <__itoa_ncheck>
 9bc:	fb 01       	movw	r30, r22
 9be:	10 82       	st	Z, r1
 9c0:	cb 01       	movw	r24, r22
 9c2:	08 95       	ret

000009c4 <__itoa_ncheck>:
 9c4:	bb 27       	eor	r27, r27
 9c6:	4a 30       	cpi	r20, 0x0A	; 10
 9c8:	31 f4       	brne	.+12     	; 0x9d6 <__itoa_ncheck+0x12>
 9ca:	99 23       	and	r25, r25
 9cc:	22 f4       	brpl	.+8      	; 0x9d6 <__itoa_ncheck+0x12>
 9ce:	bd e2       	ldi	r27, 0x2D	; 45
 9d0:	90 95       	com	r25
 9d2:	81 95       	neg	r24
 9d4:	9f 4f       	sbci	r25, 0xFF	; 255
 9d6:	0c 94 ee 04 	jmp	0x9dc	; 0x9dc <__utoa_common>

000009da <__utoa_ncheck>:
 9da:	bb 27       	eor	r27, r27

000009dc <__utoa_common>:
 9dc:	fb 01       	movw	r30, r22
 9de:	55 27       	eor	r21, r21
 9e0:	aa 27       	eor	r26, r26
 9e2:	88 0f       	add	r24, r24
 9e4:	99 1f       	adc	r25, r25
 9e6:	aa 1f       	adc	r26, r26
 9e8:	a4 17       	cp	r26, r20
 9ea:	10 f0       	brcs	.+4      	; 0x9f0 <__utoa_common+0x14>
 9ec:	a4 1b       	sub	r26, r20
 9ee:	83 95       	inc	r24
 9f0:	50 51       	subi	r21, 0x10	; 16
 9f2:	b9 f7       	brne	.-18     	; 0x9e2 <__utoa_common+0x6>
 9f4:	a0 5d       	subi	r26, 0xD0	; 208
 9f6:	aa 33       	cpi	r26, 0x3A	; 58
 9f8:	08 f0       	brcs	.+2      	; 0x9fc <__utoa_common+0x20>
 9fa:	a9 5d       	subi	r26, 0xD9	; 217
 9fc:	a1 93       	st	Z+, r26
 9fe:	00 97       	sbiw	r24, 0x00	; 0
 a00:	79 f7       	brne	.-34     	; 0x9e0 <__utoa_common+0x4>
 a02:	b1 11       	cpse	r27, r1
 a04:	b1 93       	st	Z+, r27
 a06:	11 92       	st	Z+, r1
 a08:	cb 01       	movw	r24, r22
 a0a:	0c 94 07 05 	jmp	0xa0e	; 0xa0e <strrev>

00000a0e <strrev>:
 a0e:	dc 01       	movw	r26, r24
 a10:	fc 01       	movw	r30, r24
 a12:	67 2f       	mov	r22, r23
 a14:	71 91       	ld	r23, Z+
 a16:	77 23       	and	r23, r23
 a18:	e1 f7       	brne	.-8      	; 0xa12 <strrev+0x4>
 a1a:	32 97       	sbiw	r30, 0x02	; 2
 a1c:	04 c0       	rjmp	.+8      	; 0xa26 <strrev+0x18>
 a1e:	7c 91       	ld	r23, X
 a20:	6d 93       	st	X+, r22
 a22:	70 83       	st	Z, r23
 a24:	62 91       	ld	r22, -Z
 a26:	ae 17       	cp	r26, r30
 a28:	bf 07       	cpc	r27, r31
 a2a:	c8 f3       	brcs	.-14     	; 0xa1e <strrev+0x10>
 a2c:	08 95       	ret

00000a2e <_exit>:
 a2e:	f8 94       	cli

00000a30 <__stop_program>:
 a30:	ff cf       	rjmp	.-2      	; 0xa30 <__stop_program>
